// Generated by @lagless/codegen. Do not edit manually.
import { MemoryTracker } from '@lagless/binary';

export class Transform2d {
  public static readonly ID = 1;
  public static readonly schema = {
    positionX: Float32Array,

    positionY: Float32Array,

    rotation: Float32Array,

    prevPositionX: Float32Array,

    prevPositionY: Float32Array,

    prevRotation: Float32Array,
  };

  public readonly unsafe = {} as {
    positionX: Float32Array;

    positionY: Float32Array;

    rotation: Float32Array;

    prevPositionX: Float32Array;

    prevPositionY: Float32Array;

    prevRotation: Float32Array;
  };

  private _cursorIndex = 0;
  private readonly _cursor: {
    readonly entity: number;

    readonly positionX: number;

    readonly positionY: number;

    readonly rotation: number;

    readonly prevPositionX: number;

    readonly prevPositionY: number;

    readonly prevRotation: number;
  };

  public getCursor(index: number) {
    this._cursorIndex = index;
    return this._cursor;
  }

  constructor(maxEntities: number, buffer: ArrayBuffer, memTracker: MemoryTracker) {
    for (const [fieldName, TypedArrayConstructor] of Object.entries(Transform2d.schema)) {
      const typedArray = new TypedArrayConstructor(buffer, memTracker.ptr, maxEntities);
      this.unsafe[fieldName as keyof typeof Transform2d.schema] =
        typedArray as Transform2d['unsafe'][keyof Transform2d['unsafe']];
      memTracker.add(typedArray.byteLength);
    }

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;

    this._cursor = {
      get entity(): number {
        return self._cursorIndex;
      },

      get positionX(): number {
        return self.unsafe.positionX[self._cursorIndex];
      },

      set positionX(value: number) {
        self.unsafe.positionX[self._cursorIndex] = value;
      },

      get positionY(): number {
        return self.unsafe.positionY[self._cursorIndex];
      },

      set positionY(value: number) {
        self.unsafe.positionY[self._cursorIndex] = value;
      },

      get rotation(): number {
        return self.unsafe.rotation[self._cursorIndex];
      },

      set rotation(value: number) {
        self.unsafe.rotation[self._cursorIndex] = value;
      },

      get prevPositionX(): number {
        return self.unsafe.prevPositionX[self._cursorIndex];
      },

      set prevPositionX(value: number) {
        self.unsafe.prevPositionX[self._cursorIndex] = value;
      },

      get prevPositionY(): number {
        return self.unsafe.prevPositionY[self._cursorIndex];
      },

      set prevPositionY(value: number) {
        self.unsafe.prevPositionY[self._cursorIndex] = value;
      },

      get prevRotation(): number {
        return self.unsafe.prevRotation[self._cursorIndex];
      },

      set prevRotation(value: number) {
        self.unsafe.prevRotation[self._cursorIndex] = value;
      },
    };
  }

  public static calculateSize(maxEntities: number, memTracker: MemoryTracker): void {
    for (const [, TypedArrayConstructor] of Object.entries(this.schema)) {
      memTracker.add(maxEntities * TypedArrayConstructor.BYTES_PER_ELEMENT);
    }
  }
}

Object.defineProperty(Transform2d, 'name', { value: 'Transform2d' });
