import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { cpus } from 'os';
import Rapier from '@dimforge/rapier2d-deterministic-compat';
import { Physics2dConfig } from '@lagless/physics2d';
import { CrazyBallsRunner } from './runner.js';
import { FinishError } from './systems/level.system.js';

// –§—É–Ω–∫—Ü–∏—è —Å–∏–º—É–ª—è—Ü–∏–∏ (–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è –¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ –∏ –≤–æ—Ä–∫–µ—Ä–æ–≤)
function simulate(seed: number) {
  const config = new Physics2dConfig({
    gravity: { x: 0, y: -9.81 },
    seed,
  });
  const runner = new CrazyBallsRunner(config);
  runner.start();

  let finished = false;
  while (!finished) {
    try {
      runner.update(config.frameLength);
    } catch (e) {
      finished = true;
      if (e instanceof FinishError) {
        return e.entity;
      }
    }
  }
  return undefined;
}

// –ö–æ–¥ –¥–ª—è –≤–æ—Ä–∫–µ—Ä–∞
if (!isMainThread) {
  (async () => {
    await Rapier.init();
    const { seeds } = workerData;

    for (const seed of seeds) {
      const result = simulate(seed);
      parentPort?.postMessage({ seed, result });
    }
  })();
}

// –ì–ª–∞–≤–Ω—ã–π –∫–æ–¥
else {
  async function runSimulations() {
    await Rapier.init();

    const RUNS = 10000; // –ò–∑–º–µ–Ω–∏—Ç–µ –Ω–∞ –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
    const numWorkers = cpus().length;
    const runsPerWorker = Math.ceil(RUNS / numWorkers);

    console.log(`üöÄ Running ${RUNS} simulations on ${numWorkers} threads...`);

    const resultsMap = new Map<number, number>();
    let completed = 0;
    const startTime = Date.now();

    // –°–æ–∑–¥–∞–µ–º –≤–æ—Ä–∫–µ—Ä—ã
    const workers = Array.from({ length: numWorkers }, (_, i) => {
      const start = i * runsPerWorker;
      const end = Math.min(start + runsPerWorker, RUNS);
      const seeds = Array.from({ length: end - start }, () =>
        Math.random() * Number.MAX_SAFE_INTEGER
      );

      const worker = new Worker(__filename, { workerData: { seeds } });

      worker.on('message', ({ result }) => {
        completed++;

        if (result !== undefined) {
          resultsMap.set(result, (resultsMap.get(result) ?? 0) + 1);
        }

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 100 —Å–∏–º—É–ª—è—Ü–∏–π
        if (completed % 100 === 0) {
          const progress = (completed / RUNS * 100).toFixed(1);
          const elapsed = (Date.now() - startTime) / 1000;
          const rate = completed / elapsed;
          console.log(`Progress: ${completed}/${RUNS} (${progress}%) | ${rate.toFixed(1)}/s`);
        }
      });

      return worker;
    });

    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤
    await Promise.all(workers.map(worker =>
      new Promise(resolve => worker.on('exit', resolve))
    ));

    const totalTime = (Date.now() - startTime) / 1000;
    console.log(`\n‚úÖ Completed in ${totalTime.toFixed(1)}s`);
    console.log('Results:', resultsMap);
  }

  runSimulations().catch(console.error);
}
