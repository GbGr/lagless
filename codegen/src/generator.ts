import { ECSSchema, FieldDefinition } from '@lagless/types';
import { typeToArrayConstructor, getTypeSizeBytes, typedArrayConstructors } from '@lagless/core';
import { FieldTypeReverse } from '@lagless/types';
import { generateFromTemplate as processTemplate, FileOperations } from './template-engine';

export type FileGeneratorOptions = FileOperations

export interface GenerateCodeOptions {
  schema: ECSSchema;
  projectName: string;
  outputDir: string;
  templateDir: string;
  fileOperations: FileOperations;
}

export function generateBarrelFileContent(schema: ECSSchema, projectName: string): string {
  let content = '// Generated by @lagless/codegen. Do not edit manually.\n\n';

  // Export components
  schema.components.forEach((component) => {
    content += `export * from './${component.name}.js';\n`;
  });

  // Export singletons
  schema.singletons.forEach((singleton) => {
    content += `export * from './${singleton.name}.js';\n`;
  });

  // Export player resources
  schema.playerResources.forEach((playerResource) => {
    content += `export * from './${playerResource.name}.js';\n`;
  });

  // Export filters
  schema.filters.forEach((filter) => {
    content += `export * from './${filter.name}.js';\n`;
  });

  // Export inputs
  schema.inputs.forEach((input) => {
    content += `export * from './${input.name}.js';\n`;
  });

  // Export input registry
  content += `export * from './${projectName}InputRegistry.js';\n`;

  // Export core
  content += `export * from './${projectName}.core.js';\n`;

  // Export runner
  content += `export * from './${projectName}.runner.js';\n`;

  return content;
}

export async function generateCode(options: GenerateCodeOptions): Promise<void> {
  const { schema, projectName, outputDir, templateDir, fileOperations } = options;
  const { writeFile, joinPath, exists } = fileOperations;

  // Ensure output directory exists
  if (!exists(outputDir)) {
    writeFile(joinPath(outputDir, '.gitkeep'), '');
  }

  // Generate component classes
  for (const component of schema.components) {
    await processTemplate({
      templateDir: joinPath(templateDir, 'component'),
      outputDir,
      data: {
        ...component,
        component,
        projectName,
        typeToArrayConstructor,
        getFieldByteSize: (field: FieldDefinition) => {
          const baseSize = getTypeSizeBytes(field.type);
          return field.isArray ? baseSize * field.arrayLength! : baseSize;
        },
      },
      fileOperations,
    });
  }

  // Generate singleton classes
  for (const singleton of schema.singletons) {
    await processTemplate({
      templateDir: joinPath(templateDir, 'singleton'),
      outputDir,
      data: {
        ...singleton,
        singleton,
        projectName,
        typeToArrayConstructor,
      },
      fileOperations,
    });
  }

  // Generate playerResource classes
  for (const playerResource of schema.playerResources) {
    await processTemplate({
      templateDir: joinPath(templateDir, 'playerResource'),
      outputDir,
      data: {
        ...playerResource,
        playerResource,
        projectName,
        typeToArrayConstructor,
      },
      fileOperations,
    });
  }

  // Generate Filter classes
  for (const filter of schema.filters) {
    const componentsImports = [...filter.include, ...filter.exclude].map((c) => c.name);
    const includeMask = filter.include.reduce((acc, component) => acc | component.id, 0);
    const excludeMask = filter.exclude.reduce((acc, component) => acc | component.id, 0);

    await processTemplate({
      templateDir: joinPath(templateDir, 'filter'),
      outputDir,
      data: {
        filter,
        includeMask,
        excludeMask,
        componentsImports,
        name: filter.name,
        projectName,
      },
      fileOperations,
    });
  }

  // Generate Input classes
  for (const input of schema.inputs) {
    await processTemplate({
      templateDir: joinPath(templateDir, 'input'),
      outputDir,
      data: {
        ...input,
        input,
        projectName,
        FieldTypeReverse,
        typedArrayConstructors,
      },
      fileOperations,
    });
  }

  // Generate input registry
  await processTemplate({
    templateDir: joinPath(templateDir, 'input-registry'),
    outputDir,
    data: {
      projectName,
      inputs: schema.inputs,
      schema,
    },
    fileOperations,
  });

  // Generate ECSCore class
  await processTemplate({
    templateDir: joinPath(templateDir, 'core'),
    outputDir,
    data: {
      projectName,
      schema,
    },
    fileOperations,
  });

  // Generate Runner class
  await processTemplate({
    templateDir: joinPath(templateDir, 'runner'),
    outputDir,
    data: {
      projectName,
      schema,
    },
    fileOperations,
  });

  // Generate barrel file
  const barrelContent = generateBarrelFileContent(schema, projectName);
  writeFile(joinPath(outputDir, 'index.ts'), barrelContent);
}
